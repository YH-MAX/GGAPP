"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WinAppDriverLauncher = void 0;
const logger_1 = __importDefault(require("@wdio/logger"));
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const webdriverio_1 = require("webdriverio");
const log = logger_1.default('winappdriver-service');
const LOG_FILE_NAME = 'winappdriver.log';
const WINAPPDRIVER_BIN = __dirname + '\\..\\bin\\WinAppDriver.exe';
class WinAppDriverLauncher {
    constructor(options, capabilities, config) {
        this.args = options.args || [];
        this.logPath = options.logPath || config.outputDir;
        this.command = options.command;
        this.process = null;
        const isWindows = process.platform === 'win32';
        if (!this.command) {
            this.command = WINAPPDRIVER_BIN;
        }
    }
    async onPrepare(config, capabilities) {
        const isWindows = process.platform === 'win32';
        if (isWindows) {
            await this._startWinAppDriver().then(() => {
                if (typeof this.logPath === 'string') {
                    this._redirectLogStream(this.logPath);
                }
            });
        }
        else {
            log.info('YWinAppDriver-Service is ignored on non-Windows platform');
        }
    }
    onComplete() {
        if (this.process) {
            log.debug(`YWinAppDriver (pid: ${process.pid}) is killed`);
            this.process.kill();
        }
    }
    _startWinAppDriver() {
        return new Promise((resolve, reject) => {
            log.debug(`spawn CLI process: ${this.command} ${this.args.join(' ')}`);
            const dir = path_1.dirname(this.command);
            this.process = child_process_1.spawn(this.command, this.args, { stdio: ['pipe', 'pipe', 'pipe'], cwd: dir });
            let error;
            this.process.stdout.on('data', data => {
                let s = data.toString('utf16le');
                if (s.includes('Now listening on')) {
                    log.debug(`YWinAppriver started with ID: ${process.pid}`);
                    resolve();
                }
                else if (s.includes('Unable to start')) {
                    throw new webdriverio_1.SevereServiceError('Failed to start YWinAppDriver');
                }
                let s2 = data.toString();
                if (s2.includes('Now listening on')) {
                    log.debug(`YWinAppriver started with ID: ${process.pid}`);
                    resolve();
                }
                else if (s2.includes('Unable to start')) {
                    throw new webdriverio_1.SevereServiceError('Failed to start YWinAppDriver');
                }
            });
            this.process.stderr.once('data', err => {
                log.error(err);
            });
            this.process.once('exit', exitCode => {
                let errorMessage = `CLI exited before timeout (exit code: ${exitCode})`;
                reject();
            });
        });
    }
    _redirectLogStream(logPath) {
        if (this.process) {
            const absolutePath = path_1.resolve(logPath);
            const logFile = path_1.join(absolutePath, LOG_FILE_NAME);
            fs_extra_1.ensureFileSync(logFile);
            log.debug(`YWinAppDriver logs written to: ${logFile}`);
            const logStream = fs_extra_1.createWriteStream(logFile, { flags: 'w' });
            this.process.stdout.pipe(logStream);
            this.process.stderr.pipe(logStream);
        }
    }
}
exports.WinAppDriverLauncher = WinAppDriverLauncher;
